{"posts":[{"title":"Hello World","text":"","link":"/2023/11/03/hello-world/"},{"title":"Foldable and ...","text":"Foldable and FriendsFoldableThe type class Foldable generally relies on Monoid, and it describes data structures that can be folded to a summary value, so the mappend(&lt;&gt;) defined on Monoid is needed to show that the containing data in Foldable can be combined: 12345class Foldable t where fold :: Monoid a =&gt; t a -&gt; a foldMap :: Monoid b =&gt; (a -&gt; b) -&gt; t a -&gt; b foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b Here is a foldMap example on lists: 123foldMapList :: Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; mfoldMapList f [] = memptyfoldMapList f (x:xs) = f x &lt;&gt; foldMapList f xs The minimal definition is foldMap or foldr, and using one of these two we can define them all: 123fold = foldMap idfoldMap f = foldr (mappend . f) memptytoList = foldMap (\\x -&gt; [x]) -- Here, we use the monoid of lists, which is concatenation However, the folding directions are not absolute. For example, we can define foldl in terms of foldr (even though it is not efficient enough, it still shows some type of homomorphism): 12foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; bfoldl f z ys = foldr (\\x g -&gt; g . f x) id ys z To understand the entire process, we first notice that if we want to reverse the computation order, we may leave the computation “undone”, and gradually fold other elements into the process. So in this implementation of foldl, the type b is used as the “undone” computation, i.e. function a -&gt; a (like (+) 1), and the initial value is the identity map. After iterations, we shall get: 12345id -- \\x -&gt; x\\x -&gt; f x y0\\x -&gt; f (f x y0) y1...\\x -&gt; f (... f (f (f x y0) y1) ... yN) When the folding process ends, we apply the “undone” computation to the initial value z, and we get the final result, in a reversed order. In conclusion, “Folding” is the abstraction of sequential operations (or sequential recursion) on a data structure. Example: 1map f = foldr ((:) . f) [] -- or foldMap (pure . f) TraversableNow let’s take a look at map. 123map :: (a -&gt; b) -&gt; [a] -&gt; [b]map g [] = []map g (x:xs) = g x : map g xs We get the motivation of Traversable from the need of generalizing map to deal with effects brought by various functors. 123456class (Functor t, Foldable t) =&gt; Traversable t where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)instance Traversable [] where traverse g [] = pure [] traverse g (x:xs) = pure (:) &lt;*&gt; g x &lt;*&gt; traverse g xs In the default definition of Traversable, another function sequenceA is introduced. It folds a series of effects into a single effect: 123456789sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)sequenceA = traverse id--- Examples:&gt; sequenceA [Just 1, Just 2, Just 3]Just [1, 2, 3]&gt; sequenceA [Just 1, Nothing, Just 3]Nothing We can also define traverse in turn: 1traverse g = sequenceA . fmap g","link":"/2023/11/03/Foldable-and/"},{"title":"Monadic Parser","text":"Monadic ParserParserA parser is a function that takes a string as input, then parses the string, and gives back an output. However, the process may fail as the input string may not be a valid input for the parser. To describe the result, here we use a list [a] to represent the result, where a is the type of the output, and when parsing fails, we get an empty list. 1newtype Parser a = Parser { parse :: String -&gt; [(a, String)] } Now we begin with “atoms” of parser, which consumes the smallest possible input, i.e. a char: 1234item :: Parser Charitem = Parser $ \\s -&gt; case s of [] -&gt; [] (x:xs) -&gt; [(x, xs)] Here we want to compose parsers, so declaring Parser as a Functor, Applicative, and even Monad is necessary: 12345678910111213instance Functor Parser where -- fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b fmap f (Parser p) = Parser $ \\s -&gt; [(f a, s') | (a, s') &lt;- p s]instance Applicative Parser where pure a = Parser $ \\s -&gt; [(a, s)] -- keep the input string unchanged -- (&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b pg &lt;*&gt; px = Parser $ \\s -&gt; [(g x, s'') | (g, s') &lt;- parse pg s, (x, s'') &lt;- parse px s']instance Monad Parser where return = pure -- (&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b px &gt;&gt;= f = Parser $ \\s -&gt; concat [parse (f x) s' | (x, s') &lt;- parse px s] By virtue of the do notation, we can now compose parsers easily: 12345678three = do x &lt;- item item z &lt;- item return (x, z)&gt; parse three &quot;abcdef&quot;[(('a','c'),&quot;def&quot;)] The remarkable thing is that the Monad instance of Parser allows what ,In contract, when a computation is lifted by Applicative, the type can’t be changed, so any middle operation cannot change the type of the computation. AlternativeYou may notice that we were just doing some linear parsing in the previous section. Now we want to make choices in parsing, so we need to define Alternative: 1234-- import Control.Applicativeinstance Applicative Alternative where empty :: f a (&lt;|&gt;) :: f a -&gt; f a -&gt; f a The class Alternative is a subclass of Applicative, and it is used to represent choice, by the operand &lt;|&gt;. To ensure what we implement really stands for making choices, we need to obey the following laws, which shows the essence of choice: 123Associativity: x &lt;|&gt; (y &lt;|&gt; z) = (x &lt;|&gt; y) &lt;|&gt; zLeft Identity: empty &lt;|&gt; x = xRight Identity: x &lt;|&gt; empty = x Making many &amp; some choicesThe concept is a bit like while and do-while, we repeat the computation until it fails, and we get the result. 1234567-- many : Zero or more.many :: Alternative f =&gt; f a -&gt; f [a]many v = some v &lt;|&gt; pure []-- some : One or more.some :: Alternative f =&gt; f a -&gt; f [a]some v = (:) &lt;$&gt; v &lt;*&gt; many v Their diffecence is that some must succeed at least once, while many may fail at the beginning. We use examples to clarify the difference: 12345&gt; many NothingJust []&gt; some NothingNothing Then the Parser instance serves as a perfect example of Alternative: 123456instance Alternative Parser where empty = Parser $ \\s -&gt; [] -- (&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a p &lt;|&gt; q = Parser $ \\s -&gt; case parse p s of [] -&gt; parse q s [(x, s')] -&gt; [(x, s')] Now we can use &lt;|&gt; to make choices in parsing: 1234&gt; parse (item &lt;|&gt; return 'd') &quot;abc&quot;[('a',&quot;bc&quot;)]&gt; parse (empty &lt;|&gt; return 'd') &quot;abc&quot; -- fails[('d',&quot;abc&quot;)] Get down to Parsers!We often want to make judgments on the input string, so we need to define some predicates: 1234-- Whether the next chat satisfies the predicate.sat :: (Char -&gt; Bool) -&gt; Parser Charsat p = do t &lt;- item if p t then return t else empty Then we can define some parsers that consume specific chars and strings: 1234567char :: Char -&gt; Parser Charchar c = sat (== c)string :: String -&gt; Parser Stringstring (x:xs) = do char x string xs return (x:xs) Using many, we also have something that consumes multiple spaces, processes natural numbers: 1234567space :: Parser ()space = do many (sat isSpace) return ()nat :: Parser Intnat = do xs &lt;- some digit return (read xs) When using spaces to separate different parts of the string, we can use token to consume the spaces: 123456789101112token :: Parser a -&gt; Parser atoken p = do space v &lt;- p space return v-- Tokenized parserssymbol :: String -&gt; Parser Stringsymbol xs = token $ string xsnatural :: Parser Intnatural = token nat Arithmetic ExpressionsNow we can define a parser for arithmetic expressions. Given the properties of the operators, we can describe the wanted syntax as the following context free grammar: 1234expr ::= term '+' expr | termterm ::= factor '*' term | factorfactor ::= digit | '(' expr ')'digit ::= '0' | '1' | ... | '9' Once we have the grammar, we can easily translate it into Haskell code: 123456789101112131415161718192021222324252627282930313233expr :: Parser Intexpr = do t &lt;- term do symbol &quot;+&quot; e &lt;- expr return (t + e) &lt;|&gt; do symbol &quot;-&quot; e &lt;- expr return (t - e) &lt;|&gt; return tterm :: Parser Intterm = do f &lt;- factor do symbol &quot;*&quot; t &lt;- term return (f * t) &lt;|&gt; do symbol &quot;/&quot; t &lt;- term return (f `div` t) &lt;|&gt; return ffactor :: Parser Intfactor = do symbol &quot;(&quot; e &lt;- expr symbol &quot;)&quot; return e &lt;|&gt; natural Finally it’s time to parse and evaluate the final value! 12eval :: String -&gt; Inteval = fst . head . parse expr","link":"/2023/11/04/Monadic-Parser/"},{"title":"连续函数的几个问题！","text":"Q $g(x)$ 是定义在 $ [0,1] $ 上的函数，满足 $ g(0)=1,g(1)=0 $，如果函数 $ g(x)+ \\tan x $ 单调上升，证明：$ g(x) $可以取到 $ [0,1] $ 内任意的值. Proof 考虑更一般的问题： $ f(x) $ 是 $ [0,1] $ 上的连续函数， $g(x)$ 是定义在 $ [0,1] $ 上的函数，满足 $ g(0)&gt;0,g(1)&lt;0 $，如果函数 $ f(x) + g(x) $ 单调上升，证明：$ g(x) $ 有零点. 考虑构造集合 $ A={x \\mid g(x) \\geqslant 0} $，我们取 $ c=\\sup A $ 并证明 $ c $ 就是 $ g(x) $ 的零点. $ t&gt;c $ 时，$$ f(t)\\geqslant f(t)+g(t)\\geqslant f(c)+g(c) $$ 这说明 $ g(c)\\leqslant f(t)-f(c) $， 两边取 $ t\\to c $ 的极限，由于 $ f(x) $ 连续， $ g(c)\\leqslant 0 $. $ t&lt;c $ 时，类似得到$$ f(t)\\leqslant f(t)+g(t)\\leqslant f(c)+g(c)$$ 这说明 $ g(c)\\geqslant f(t)-f(c) $， 两边取 $ t\\to c $ 的极限，由于 $ f(x) $ 连续， $ g(c)\\geqslant 0 $. 综上， $ g(c)=0 $，即 $ c $ 是 $ g(x) $ 的零点. 回到原问题，对于任意的 $\\eta \\in [0,1] $ 取 $ f(x)=\\tan x $，$ h(x)=g(x)-\\eta $，对于 $ f(x) $ 和 $ h(x) $ 应用上面的结论，我们知道 $ h(x) $ 有零点，即 $ g(x) $ 可以取到 $ [0,1] $ 内任意的值.","link":"/2023/11/04/Problems-on-Contiunity/"}],"tags":[{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"}],"categories":[{"name":"Functional Programming","slug":"Functional-Programming","link":"/categories/Functional-Programming/"},{"name":"Calculus","slug":"Calculus","link":"/categories/Calculus/"}],"pages":[{"title":"links","text":"nstd::out - 非标准输出","link":"/links/index.html"}]}