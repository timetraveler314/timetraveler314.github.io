{"posts":[{"title":"Hello World","text":"","link":"/2023/11/03/hello-world/"},{"title":"Foldable and ...","text":"Foldable and FriendsFoldableThe type class Foldable generally relies on Monoid, and it describes data structures that can be folded to a summary value, so the mappend(&lt;&gt;) defined on Monoid is needed to show that the containing data in Foldable can be combined: 12345class Foldable t where fold :: Monoid a =&gt; t a -&gt; a foldMap :: Monoid b =&gt; (a -&gt; b) -&gt; t a -&gt; b foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b Here is a foldMap example on lists: 123foldMapList :: Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; mfoldMapList f [] = memptyfoldMapList f (x:xs) = f x &lt;&gt; foldMapList f xs The minimal definition is foldMap or foldr, and using one of these two we can define them all: 123fold = foldMap idfoldMap f = foldr (mappend . f) memptytoList = foldMap (\\x -&gt; [x]) -- Here, we use the monoid of lists, which is concatenation However, the folding directions are not absolute. For example, we can define foldl in terms of foldr (even though it is not efficient enough, it still shows some type of homomorphism): 12foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; bfoldl f z ys = foldr (\\x g -&gt; g . f x) id ys z To understand the entire process, we first notice that if we want to reverse the computation order, we may leave the computation “undone”, and gradually fold other elements into the process. So in this implementation of foldl, the type b is used as the “undone” computation, i.e. function a -&gt; a (like (+) 1), and the initial value is the identity map. After iterations, we shall get: 12345id -- \\x -&gt; x\\x -&gt; f x y0\\x -&gt; f (f x y0) y1...\\x -&gt; f (... f (f (f x y0) y1) ... yN) When the folding process ends, we apply the “undone” computation to the initial value z, and we get the final result, in a reversed order. In conclusion, “Folding” is the abstraction of sequential operations (or sequential recursion) on a data structure. Example: 1map f = foldr ((:) . f) [] -- or foldMap (pure . f) TraversableNow let’s take a look at map. 123map :: (a -&gt; b) -&gt; [a] -&gt; [b]map g [] = []map g (x:xs) = g x : map g xs We get the motivation of Traversable from the need of generalizing map to deal with effects brought by various functors. 123456class (Functor t, Foldable t) =&gt; Traversable t where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)instance Traversable [] where traverse g [] = pure [] traverse g (x:xs) = pure (:) &lt;*&gt; g x &lt;*&gt; traverse g xs In the default definition of Traversable, another function sequenceA is introduced. It folds a series of effects into a single effect: 123456789sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)sequenceA = traverse id--- Examples:&gt; sequenceA [Just 1, Just 2, Just 3]Just [1, 2, 3]&gt; sequenceA [Just 1, Nothing, Just 3]Nothing We can also define traverse in turn: 1traverse g = sequenceA . fmap g","link":"/2023/11/03/Foldable-and/"}],"tags":[{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"}],"categories":[{"name":"Functional Programming","slug":"Functional-Programming","link":"/categories/Functional-Programming/"}],"pages":[]}